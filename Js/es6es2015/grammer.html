<html>
<head>
    <title>grammer.html</title>

    <link href="../common/assets/css/common.css" rel="stylesheet"/>

</head>


<body>
grammer.html page<br/>

最常用的ES6特性<br/>

let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments

<div id="container">
</div>

</body>


<!--<%&#45;&#45;Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。&#45;&#45;%>-->
<!--第二代编译器——babel-->
<!--React官方博客发布了一篇文章，声明其自身用于JSX语法解析的编译器JSTransform已经过期，
不再维护，React JS和React Native已经全部采用第三方Babel的JSX编译器实现。
原因是两者在功能上已经完全重复，而Babel作为专门的JavaScript语法编译工具，提供了更为强大的功能。
而browser.js是babel编译器的浏览器版本。-->
<script src="../common/assets/js/react/browser.min.js" type="text/javascript"></script>
<!--<%&#45;&#45;<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.24/browser.min.js"></script>&#45;&#45;%>-->



<!--<%&#45;&#45;注意！！type&#45;&#45;%>-->
<script type="text/babel">
//    var name = 'zach'
//
//    while (true) {
//        var name = 'obama'
//        console.log(name)  //obama
//        break
//    }

    console.log(name)  //obama

    let name = 'zach'

    while (true) {
        let name = 'obama'
        console.log(name)  //obama
        break
    }

    console.log(name)  //zach



    function aaaa() {
        for (var j = 0; j < 10; j++) {

        }
        console.log("es5:"+j);

        //compile error
//        for (let k = 0; k < 10; k++) {
//
//        }
//        console.log("es6:"+k);//Uncaught ReferenceError: k is not defined
    }
    aaaa();
//    console.log("es5:"+j); compile error j is not defined
</script>


<script type="text/babel">
    const PI = Math.PI

//    PI = 23 //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only
</script>

<script type="text/babel">
    class Animal {
        constructor(){
            this.type = 'animal'
        }
        says(say){
            console.log(this.type + ' says ' + say)
        }
    }

    let animal = new Animal()
    animal.says('hello') //animal says hello

    class Cat extends Animal {
        constructor(){
            super()
            this.type = 'cat'
        }
    }

    let cat = new Cat()
    cat.says('hello') //cat says hello
</script>

<script type="text/babel">
//    function(i){ return i + 1; } //ES5
    let fc = (i) => i + 1 //ES6
    let fc2 = (x, y) => {x++; y--; return x+y} //ES6
    console.log(fc(2));
    console.log(fc2(3,5));
</script>
<script type="text/babel">

//    当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
//    并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的
// ，因此内部的this就是外层代码块的this。
    class Animal2 {
        constructor(){
            this.type = 'animal'
        }
        says(say){
            setTimeout( () => {
                console.log("Animal2:"+this.type + ' says ' + say)
            }, 1000)
        }
    }
    var animal = new Animal2()
    animal.says('hi')  //animal says hi
</script>

<script type="text/babel">
    class Animal3 {
        constructor(){
            this.type = 'animal'
        }
        says(say){
            setTimeout(function(){
                console.log("Animal3:"+this.type + ' says ' + say)
            }, 1000)
        }
    }

    var animal = new Animal3()
    animal.says('hi')  //undefined says hi
</script>

<script type="text/babel">
//    template string
    var basket = {count:3,onSale:4};//缺少字段会报错
   var str =  `
      There are <b>${basket.count}</b> items
       in your basket, <em>${basket.onSale}</em>
      are on sale!
    `
    console.log(str);
</script>

<script type="text/babel">
//    destructuring 解构
    let cat = 'ken'
    let dog = 'lili'
    let zoo = {cat, dog}
    console.log(zoo)  //Object {cat: "ken", dog: "lili"}

    let dog2 = {type: 'animal', many: 2}
    let { type, many} = dog2
    console.log(type, many)   //animal 2
</script>

<script type="text/babel">
//    default, rest
//function animal(type){
//    type = type || 'cat'
//    console.log(type)
//}
//animal()  //es5


function animal(type = 'cat'){
    console.log(type)
}
animal();//es6


//最后一个rest语法也很简单，直接看例子：
function animals(...types){
    console.log(types)
}
animals('cat', 'dog', 'fish') //["cat", "dog", "fish"]
</script>

</html>
