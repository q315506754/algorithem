【原型链
每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。

这个属性包含一个对象（以下简称"prototype对象"），所有实例对象需要共享的属性和方法，都放在这个对象里面；
那些不需要共享的属性和方法，就放在构造函数里面。

实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。

由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，
而实例对象则好像"继承"了prototype对象一样。


　function DOG(name){
　　　　this.name = name;
　　}
　　DOG.prototype = { species : '犬科' };

　　var dogA = new DOG('大毛');
　　var dogB = new DOG('二毛');

　　console.log(dogA.species); // 犬科
　　console.log(dogB.species); // 犬科
    DOG.prototype.species = '猫科';
　　console.log(dogA.species); // 猫科
　　console.log(dogB.species); // 猫科


    function CAT(name){
    　　this.name = name;
    }
    CAT.prototype = DOG.prototype;
    var catA = new DOG('cca');
    var catB = new DOG('ccb');
    console.log(catA.species); // 猫科
　　console.log(catB.species); // 猫科
     DOG.prototype.species = '喵咪科';
     console.log(catA.species); // 喵咪科
     console.log(catB.species); // 喵咪科
     console.log(dogA.species); // 喵咪科
     console.log(dogB.species); // 喵咪科

【闭包
Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。
闭包就是能够读取其他函数内部变量的函数。
因此可以把闭包简单理解成"定义在一个函数内部的函数"。
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。
用途:
一个是前面提到的可以读取函数内部的变量，
另一个就是让这些变量的值始终保持在内存中。

原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，
因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收

注意点:
1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

【同步
【异步

【call bind

【canvas

【渲染,重排和重绘
网页的生成过程，大致可以分成五步。
HTML代码转化成DOM
CSS代码转化成CSSOM（CSS Object Model）
结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
生成布局（layout），即将所有渲染树的所有节点进行平面合成
将布局绘制（paint）在屏幕上
这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。

window.requestAnimationFrame() 它可以将某些代码放到下一次重新渲染时执行。
window.requestIdleCallback()  它指定只有当一帧的末尾有空闲时间，才会执行回调函数。
            它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。





