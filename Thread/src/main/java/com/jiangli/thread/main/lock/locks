https://www.cnblogs.com/lxmyhappy/p/7380073.html

粒度
公平
并发


公平 非公平 按照申请锁的顺序来获取锁 默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

可重入 不可重入 可重入锁又名递归锁，对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。

读偏向锁 写偏向锁

乐观锁 悲观锁 是指看待并发同步的角度。悲观的认为，不加锁的并发操作一定会出问题。乐观在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。悲观锁在Java中的使用，就是利用各种锁。
                          乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

独享锁 共享锁  独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。

互斥锁/读写锁
上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
互斥锁在Java中的具体实现就是ReentrantLock
读写锁在Java中的具体实现就是ReadWriteLock

分段锁 一种锁的设计，并非具体的一种锁。ConcurrentHashMap中的分段锁称为Segment。即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
        当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
        但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
        分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

偏向锁/轻量级锁/重量级锁


自旋锁
在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。


MVCC Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法
CopyOnWrite